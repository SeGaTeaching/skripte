Absolut. Hier ist der detaillierte Gliederungs-Vorschlag für den nächsten großen Themenblock, basierend auf deinem neuen Plan. Dieser Block konzentriert sich voll auf die logische Planung und das Design von Programmen, bevor eine einzige Zeile Code geschrieben wird.

---
## Vorschlag: Detaillierte Gliederung für Block 2

### **Block 2: Refresh Programmiergrundlagen**

> _**Anmerkung für den Lehrer:** Dieser Block ist sehr visuell und methodisch. Es ist ideal, die Diagramme (PAP, Struktogramm) live an einem Whiteboard oder in einem einfachen Diagramm-Tool zu entwickeln._

#### **Kapitel 1: Programmierlogik (Das Fundament des Denkens)**
* **Analogie:** Der Architekten-Bauplan. Bevor der erste Ziegel gesetzt wird, wird die gesamte Statik und Aufteilung des Hauses geplant. Das ist Programmierlogik.
* **Theorie:**
    * **Top-Down-Design:** Das Kernprinzip, ein großes, unübersichtliches Problem (z.B. "Baue eine Kundenverwaltung") systematisch in immer kleinere, lösbare Teilprobleme zu zerlegen.
    * **Die 3 Bausteine:** Wiederholung der Tatsache, dass jedes lösbare Problem mit nur drei Grundstrukturen aufgebaut werden kann:
        * **Sequenz** (Schritt-für-Schritt-Ablauf)
        * **Selektion** (Unsere `if-else`-Verzweigungen)
        * **Iteration** (Unsere `while`/`for`-Schleifen)
* **Praxis-Demo (Gedankenexperiment):**
    * Wir nehmen ein Alltagsproblem wie "Morgens zur Arbeit kommen" und zerlegen es gemeinsam mit den Schülern live in logische Teilschritte (Aufstehen -> Duschen -> Anziehen -> Frühstücken -> Fahren).

#### **Kapitel 2: Pseudocode (Die Brückensprache)**
* **Theorie:**
    * Was ist Pseudocode? Eine strukturierte, menschlich lesbare Beschreibung eines Algorithmus, die bewusst die strenge Syntax von Programmiersprachen ignoriert. Es ist die formalisierte Version eines Kochrezepts.
    * Wir etablieren einfache, einheitliche Schlüsselwörter, z.B.: `START`, `ENDE`, `EINGABE`, `AUSGABE`, `WENN...DANN...SONST`, `SOLANGE...MACHE`, `FÜR...MACHE`.
* **Praxis-Demo:**
    * Wir nehmen eine Aufgabe aus unserem letzten Übungs-Set (z.B. den "Noten-Rechner") und schreiben die Lösungslogik zuerst als sauberen Pseudocode, bevor wir uns den echten Code ansehen.

#### **Kapitel 3: Programmablaufpläne (PAP / Flowcharts)**
* **Theorie:**
    * Einführung in die grafische Darstellung von Algorithmen nach DIN 66001.
    * Vorstellung der wichtigsten Symbole:
        * **Oval:** Start / Ende
        * **Rechteck:** Anweisung / Operation
        * **Raute (Diamant):** Entscheidung / Verzweigung
        * **Parallelogramm:** Ein- / Ausgabe
* **Praxis-Demo:**
    * Wir zeichnen einen PAP für das "Noten-Feedback"-Beispiel und zeigen, wie die `if-elif-else`-Kette als eine Reihe von Rauten dargestellt wird.
    * Wir zeichnen einen PAP für eine `while`-Schleife und zeigen, wie der Kontrollfluss-Pfeil eine Schleife zurück zur Bedingung bildet.

#### **Kapitel 4: Struktogramme (Nassi-Shneiderman-Diagramme)**
* **Theorie:**
    * Vorstellung der zweiten Visualisierungsmethode: Struktogramme als blockorientierte, pfeilfreie Alternative zum PAP, die "Spaghetti-Code" von vornherein verhindert.
    * Vorstellung der Grundstrukturen für Sequenz, Selektion (`if-else`) und Iteration (`while`, `for`).
* **Praxis-Demo:**
    * Wir nehmen exakt dieselben Beispiele wie beim PAP (z.B. "Noten-Feedback" und die `while`-Schleife) und setzen sie als Struktogramm um.
    * Dadurch können die Schüler die Vor- und Nachteile beider Methoden direkt vergleichen.

---
Passt dieser detaillierte Plan für den zweiten Block, um die Grundlagen der Programm-Planung zu vermitteln?