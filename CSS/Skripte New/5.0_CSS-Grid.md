# Tag 5 CSS: Grid

CSS Grid ist eines der leistungsf√§higsten Layoutsysteme in CSS. Es erlaubt die Erstellung von **zweidimensionalen Layouts** ‚Äì also Spalten und Zeilen gleichzeitig ‚Äì und ist besonders n√ºtzlich f√ºr komplexe, strukturierte Layouts, wie z.‚ÄØB. Dashboard-Layouts, Seitenlayouts mit mehreren Bereichen oder responsive Raster.

---

## 1. Einf√ºhrung in CSS Grid

**CSS Grid Layout** wurde eingef√ºhrt, um eine native, deklarative M√∂glichkeit zu schaffen, Elemente **zweidimensional anzuordnen**. Es bietet:

- vollst√§ndige Kontrolle √ºber Zeilen und Spalten
- Flexibilit√§t durch dynamische Gr√∂√üenvergabe (`fr`, `auto`, `minmax()`)
- klar definierbare Bereiche durch `grid-template-areas`
- einfache Integration mit Media Queries

**Unterschied zu Flexbox:**
- **Flexbox** eignet sich besser f√ºr lineare Layouts (1D)
- **Grid** eignet sich besser f√ºr strukturierte Raster (2D)

---
---

## 2. Grundstruktur: Grid-Container und Grid-Items

### a) Der Grid-Container
Ein Container wird durch `display: grid` (oder `inline-grid`) zum **Grid-Container**:

```css
.container {
  display: grid;
}
```

### b) Die Grid-Items
Alle direkten Kindelemente eines Grid-Containers sind automatisch **Grid-Items**. Jedes dieser Elemente kann einzeln gesteuert werden ‚Äì Position, Gr√∂√üe, Ausrichtung etc.

> Nur direkte Kinder eines Grid-Containers sind Grid-Items!

---
---

## 3. Zeilen und Spalten definieren

Um mit CSS Grid ein Raster zu erzeugen, m√ºssen **Spalten (columns)** und **Zeilen (rows)** definiert werden. Daf√ºr verwendet man die Eigenschaften `grid-template-columns` und `grid-template-rows` im Grid-Container.

---

### a) Spalten definieren mit `grid-template-columns`

Diese Eigenschaft legt fest:
- **Wie viele Spalten** es im Grid gibt
- **Wie breit** jede Spalte sein soll

```css
.container {
  display: grid;
  grid-template-columns: 1fr 2fr 1fr;
}
```

In diesem Beispiel:
- Es gibt **drei Spalten**
- Die mittlere Spalte ist **doppelt so breit** wie die √§u√üeren

#### M√∂gliche Einheiten f√ºr Spaltenbreiten:
- `px`: feste Breite (z.‚ÄØB. `200px`)
- `%`: relativ zur Breite des Containers (z.‚ÄØB. `50%`)
- `fr`: **Fractional Unit** ‚Äì verteilt verbleibenden Platz nach Anteilen
- `auto`: passt sich dem Inhalt an
- `minmax()`: definiert minimalen und maximalen Bereich f√ºr Spalten

#### Beispiel mit `minmax()`
```css
grid-template-columns: minmax(150px, 1fr) 2fr;
```

> Erm√∂glicht responsives Verhalten bei gleichzeitiger Begrenzung der Mindestgr√∂√üe

#### Die Funktion `repeat()`
Wenn mehrere Spalten gleich aufgebaut sind, kann man sie mit `repeat()` k√ºrzer schreiben:

```css
.container {
  grid-template-columns: repeat(3, 1fr); /* drei gleich breite Spalten */
}
```

Man kann auch `repeat()` mit anderen Einheiten kombinieren:
```css
.container {
  grid-template-columns: 200px repeat(2, 1fr) 100px;
}
```

#### Beispiel mit `minmax()` und `auto-fit`
```css
.container {
  grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
}
```
> Dieses Muster passt sich flexibel der Containerbreite an und erzeugt responsive Spalten.

---
---

### b) Zeilen definieren mit `grid-template-rows`

Mit `grid-template-rows` wird die **H√∂he der Zeilen** festgelegt ‚Äì analog zu den Spalten.

```css
.container {
  grid-template-rows: 100px auto 50px;
}
```

In diesem Beispiel:
- Die erste Zeile ist **fix 100px hoch**
- Die zweite Zeile passt sich **dynamisch** dem Inhalt an
- Die dritte Zeile ist wieder **fix auf 50px** begrenzt

#### Auch hier gilt:
- `fr`, `auto`, `minmax()`, `repeat()` sind ebenso g√ºltig wie bei Spalten

```css
.container {
  grid-template-rows: repeat(3, 150px);
}
```

> Zeilenh√∂hen beeinflussen nur die direkte Fl√§che der Grid-Zellen, nicht deren Inhalt ‚Äì z.‚ÄØB. kann ein hoher Inhalt `auto`-Zeilenh√∂he erzeugen

#### Dynamische Zeilenh√∂he mit `min-content` / `max-content`
```css
.container {
  grid-template-rows: min-content auto max-content;
}
```
- `min-content`: kleinster m√∂glicher Inhalt (z.‚ÄØB. Textumbruch)
- `max-content`: gr√∂√üte nat√ºrliche Breite/H√∂he des Inhalts

---
---

> **Tipp:** Kombiniere `repeat()` und `minmax()` f√ºr flexible responsive Layouts:
```css
grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
```

---
---

## 4. Abstand: `gap`

Die Eigenschaft `gap` definiert den **Abstand zwischen Spalten und Zeilen** (vormals `grid-gap`).

```css
.container {
  gap: 20px; /* gleichm√§√üig */
  row-gap: 10px;
  column-gap: 30px;
}
```

> Vorteil gegen√ºber `margin`: Kein ‚Äûdoppelter Abstand‚Äú zwischen benachbarten Grid-Items

---
---

## 5. Positionierung im Grid

Mit CSS Grid kannst du einzelne Items pr√§zise innerhalb des Rasters positionieren. Jedes Grid-Item kann genau an bestimmten **Spalten- und Zeilenlinien** ausgerichtet werden. Dabei orientierst du dich nicht an Zellen, sondern an **Grid-Linien** ‚Äì das ist ein entscheidender Unterschied.

---

###  Visualisierung eines Grid-Rasters (3 Spalten √ó 4 Zeilen)

```plaintext
+-----+-----+-----+
|     |     |     |  ‚Üê Zeile 1
+-----+-----+-----+
|‚ñà‚ñà‚ñà‚ñà‚ñà|‚ñà‚ñà‚ñà‚ñà‚ñà|     |  ‚Üê Zeile 2
+-----+-----+-----+
|‚ñà‚ñà‚ñà‚ñà‚ñà|‚ñà‚ñà‚ñà‚ñà‚ñà|     |  ‚Üê Zeile 3
+-----+-----+-----+
|     |     |     |  ‚Üê Zeile 4
+-----+-----+-----+
  ‚Üë     ‚Üë     ‚Üë
  1     2     3   ‚Üê Spaltenlinien
```

> In diesem Beispiel erstreckt sich ein Element von **Spalte 1 bis 3** (2 Spalten breit) und **Zeile 2 bis 4** (2 Zeilen hoch).

---

### a) Spalten-Positionierung mit `grid-column`

```css
.item {
  grid-column-start: 1;
  grid-column-end: 3; /* endet an Linie 3 ‚Üí deckt Spalten 1 + 2 ab */
}
```

#### Kurzschreibweise:
```css
.item {
  grid-column: 1 / 3;
}
```

**Tipp**: Du kannst auch das Keyword `span` verwenden:

```css
.item {
  grid-column: 1 / span 2; /* starte bei Linie 1, spanne 2 Spalten */
}
```

---

### b) Zeilen-Positionierung mit `grid-row`

```css
.item {
  grid-row-start: 2;
  grid-row-end: 4; /* deckt Zeile 2 + 3 ab */
}
```

#### Kurzschreibweise:
```css
.item {
  grid-row: 2 / 4;
}
```

Auch hier kannst du `span` nutzen:

```css
.item {
  grid-row: 2 / span 2; /* startet in Zeile 2, erstreckt sich √ºber 2 Zeilen */
}
```

> **Hinweis:** Grid-Positionierung basiert immer auf **Linien**, nicht auf Zellen. Du z√§hlst also von **Linie zu Linie** ‚Äì der Bereich dazwischen ist die sichtbare Fl√§che.

---

### ‚ú® Weitere Beispiele

#### Beispiel 1: Item, das nur 1 Zelle (1x1) einnimmt
```css
.item {
  grid-column: 2 / 3;
  grid-row: 3 / 4;
}
```

#### Beispiel 2: Item, das sich √ºber alle drei Spalten erstreckt
```css
.item {
  grid-column: 1 / 4;
}
```

#### Beispiel 3: Dynamische Position mit `auto`
```css
.item {
  grid-column: auto / span 2; /* beginne automatisch und nehme 2 Spalten ein */
}
```

> Praktisch, wenn Items dynamisch einsortiert werden sollen, ohne feste Startlinie

---
---

## 6. Layout mit `grid-template-areas`

Mit `grid-template-areas` kannst du das Layout einer Webseite **visuell lesbar, semantisch benannt und intuitiv gestaltet** definieren. Es ist besonders n√ºtzlich, wenn du eine klare Struktur wie **Header ‚Äì Navigation ‚Äì Content ‚Äì Footer** darstellen m√∂chtest.

---

### Was ist `grid-template-areas`?
Statt mit numerischen Linien (`grid-column: 1 / 3`) zu arbeiten, gibst du deinem Grid eine **zeichnerische Struktur**, in der jeder Bereich einen Namen bekommt. Das erleichtert nicht nur die Planung, sondern verbessert auch die Wartbarkeit deines Codes.

---

### Beispiel: Layout mit 3 Spalten und 3 Zeilen
```css
.container {
  display: grid;
  grid-template-columns: 200px 1fr 1fr;
  grid-template-rows: 80px 1fr 60px;
  grid-template-areas:
    "header  header  header"
    "nav     content content"
    "nav     footer  footer";
  gap: 10px;
}
```

### Was passiert hier?
- **Zeile 1:** Ein durchgehender Header √ºber alle drei Spalten
- **Zeile 2:** Navigation links, Content rechts
- **Zeile 3:** Navigation bleibt links, Footer rechts unten

Diese Struktur liest sich wie ein **Bauplan**, direkt im CSS. 

---

### Zuweisung der Bereiche mit `grid-area`
Jedes Grid-Item im HTML bekommt ein passendes Label, z.‚ÄØB.:
```css
.header  { grid-area: header; }
.nav     { grid-area: nav; }
.content { grid-area: content; }
.footer  { grid-area: footer; }
```

Dein HTML dazu k√∂nnte so aussehen:
```html
<div class="container">
  <div class="header">Header</div>
  <div class="nav">Navigation</div>
  <div class="content">Content</div>
  <div class="footer">Footer</div>
</div>
```

---

### Regeln bei `grid-template-areas`

- **Alle Namen m√ºssen zusammenh√§ngende Rechtecke bilden.** Du darfst keine L-f√∂rmigen oder gesplitteten Bereiche mit demselben Namen definieren.
- **Nicht belegte Zellen** werden mit einem Punkt `.` dargestellt:

```css
grid-template-areas:
  "header header header"
  "nav    content ."
  "footer footer footer";
```
- **Anzahl der Spalten und Zeilen** in `grid-template-areas` muss mit `grid-template-columns` und `-rows` √ºbereinstimmen!

---

### Dynamische Anpassung mit Media Queries
Du kannst `grid-template-areas` auch in Media Queries neu definieren, z.‚ÄØB.:
```css
@media (max-width: 768px) {
  .container {
    grid-template-areas:
      "header"
      "nav"
      "content"
      "footer";
    grid-template-columns: 1fr;
    grid-template-rows: auto;
  }
}
```
> Ergebnis: Mobilger√§t zeigt die vier Bereiche untereinander, perfekt f√ºrs Responsive Design

---
---

## 7. Ausrichtung im Grid

In CSS Grid kannst du sowohl die **Ausrichtung einzelner Items** innerhalb ihrer Zelle steuern als auch die **Gesamtausrichtung** des Grids im Container beeinflussen. Dadurch entsteht ein hohes Ma√ü an Kontrolle √ºber Layout und Gestaltung ‚Äì besonders bei responsiven Designs.

---

### Ausrichtung einzelner Grid-Items

Diese beiden Eigenschaften wirken **auf jedes Item einzeln** innerhalb seiner Zelle:

#### a) `justify-self` (horizontal innerhalb der Zelle)
- Steuert die horizontale Ausrichtung des Inhalts **innerhalb der eigenen Spalte**
- G√ºltige Werte:
  - `start`: linksb√ºndig (bzw. am Anfang der Spalte)
  - `end`: rechtsb√ºndig (am Ende der Spalte)
  - `center`: zentriert in der Spalte
  - `stretch` (Standard): dehnt sich √ºber die volle Spaltenbreite

```css
.item {
  justify-self: center;
}
```

#### b) `align-self` (vertikal innerhalb der Zelle)
- Steuert die vertikale Ausrichtung des Inhalts **innerhalb der Zeile**
- G√ºltige Werte:
  - `start`: oben innerhalb der Zelle
  - `end`: unten innerhalb der Zelle
  - `center`: vertikal zentriert
  - `stretch` (Standard): dehnt sich √ºber volle Zellenh√∂he

```css
.item {
  align-self: end;
}
```

> N√ºtzlich, um einzelne Grid-Elemente besonders hervorzuheben oder abweichend zu platzieren

---

### Standardausrichtung f√ºr alle Items im Grid

Diese Eigenschaften definieren das **Standardverhalten f√ºr alle Grid-Items**, sofern `justify-self` / `align-self` nicht √ºberschrieben wird.

#### a) `justify-items` (horizontal innerhalb der Zellen)
```css
.container {
  justify-items: center; /* alle Items horizontal zentriert */
}
```

#### b) `align-items` (vertikal innerhalb der Zellen)
```css
.container {
  align-items: stretch; /* alle Items f√ºllen die Zellenh√∂he */
}
```

> Wird h√§ufig zusammen verwendet, um gleichm√§√üige Ausrichtung √ºber alle Items hinweg zu gew√§hrleisten

G√ºltige Werte (wie bei `self`):
- `start`, `end`, `center`, `stretch`

---

### Ausrichtung des gesamten Grid-Inhalts im Container

Diese Eigenschaften betreffen **das gesamte Grid** im Container ‚Äì also wie die **Grid-Zeilen und -Spalten** innerhalb des Containers positioniert werden, wenn **mehr Platz verf√ºgbar ist als n√∂tig**.

#### a) `justify-content` (horizontal)
- Richtet das gesamte Grid horizontal im √ºbergeordneten Container aus
- Funktioniert nur, wenn der Container **mehr Platz hat**, als das Grid ben√∂tigt

M√∂gliche Werte:
- `start`, `end`, `center`
- `space-between`, `space-around`, `space-evenly`
- `stretch` (nicht in allen Browsern unterst√ºtzt)

```css
.container {
  justify-content: space-between;
}
```

#### b) `align-content` (vertikal)
- Richtet das Grid vertikal im Container aus (z.‚ÄØB. wenn weniger Zeilen da sind als Containerh√∂he)

```css
.container {
  align-content: center;
}
```

> Beide Eigenschaften funktionieren nur, wenn das Grid kleiner ist als sein Elternelement ‚Äì √§hnlich wie `flexbox`-Verhalten bei `justify-content`

---

### üß™ Beispiel ‚Äì zentriertes Grid mit zentrierten Items:
```css
.container {
  display: grid;
  grid-template-columns: repeat(3, 150px);
  grid-template-rows: repeat(2, 100px);
  justify-content: center;
  align-content: center;
  justify-items: center;
  align-items: center;
  gap: 20px;
  height: 100vh;
}
```

---

### Tipp:
Du kannst innerhalb eines Grid-Items auch **Flexbox** verwenden, um **mehrdimensionale Ausrichtung** zu erreichen:

```css
.item {
  display: flex;
  justify-content: center;
  align-items: center;
}
```

> Kombiniere Grid f√ºr das gro√üe Layout, Flexbox f√ºr die Inhalte innerhalb der Boxen ‚Äì Best of Both Worlds.

---
---

## 8. Responsive Design mit CSS Grid

### Flexibles Raster mit Media Queries
```css
.container {
  grid-template-columns: 1fr;
}

@media (min-width: 600px) {
  .container {
    grid-template-columns: repeat(3, 1fr);
  }
}
```

### Automatisches Layout mit `auto-fit` / `auto-fill`
```css
grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
```

- `auto-fill`: f√ºllt so viele Spalten wie m√∂glich, auch leere
- `auto-fit`: passt sich aktiven Items an

> Sehr n√ºtzlich f√ºr Galerien oder dynamische Inhalte

---
---

## 9. √úbungsaufgaben (WDA-konform, kompetenzorientiert)

### Aufgabe 1
Erstelle ein Layout mit drei Spalten, bei dem die mittlere Spalte doppelt so viel Platz einnimmt wie die √§u√üeren.

### Aufgabe 2
Setze ein Raster mit unterschiedlichen Zeilenh√∂hen und nutze flexible Ma√üeinheiten, um die Inhalte dynamisch darzustellen.

### Aufgabe 3
Baue ein semantisches Grid mit benannten Bereichen f√ºr Header, Navigation, Content und Footer.

### Aufgabe 4
Gestalte ein Layout, in dem ein einzelnes Element zwei Zeilen und zwei Spalten √ºberspannt ‚Äì positioniere es pr√§zise.

### Aufgabe 5
Erstelle ein responsives Grid, das sich bei kleinen Bildschirmen in eine Spalte umwandelt, bei gr√∂√üeren in drei.

### Aufgabe 6
Entwirf ein flexibles Galerie-Layout mit automatisch anpassbarer Spaltenanzahl, das sich an die Breite des Containers anpasst.

---

## üîí Nur f√ºr den Dozenten: Demo-HTML & CSS zur Live-Vorf√ºhrung

**index.html**
```html
<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CSS Grid Demo</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <div class="container">
    <div class="item header">Header</div>
    <div class="item nav">Navigation</div>
    <div class="item content">Content</div>
    <div class="item footer">Footer</div>
  </div>
</body>
</html>
```

**style.css**
```css
body {
  font-family: sans-serif;
  padding: 2rem;
}

.container {
  display: grid;
  grid-template-areas:
    "header header header"
    "nav content content"
    "nav footer footer";
  grid-template-columns: 200px 1fr 1fr;
  grid-template-rows: 80px 1fr 60px;
  gap: 10px;
}

.header { grid-area: header; background: #cce; }
.nav    { grid-area: nav; background: #ecc; }
.content{ grid-area: content; background: #cec; }
.footer { grid-area: footer; background: #ccc; }

.item {
  padding: 1rem;
  border: 1px solid #999;
}
```

---

## 11. Zusammenfassung

CSS Grid ist das leistungsf√§higste native Layoutsystem in CSS. Mit wenig Code lassen sich komplexe Layouts erstellen, die sich sauber an Inhalte und Bildschirmgr√∂√üen anpassen. Durch Kombination mit Flexbox oder Media Queries entsteht ein modernes, flexibles und wartbares Webdesign.

---

